1. You are given an infix expression.
2. You are required to convert it to postfix and print it.
3. You are required to convert it to prefix and print it.
Constraints
1. Expression is balanced
2. The only operators used are +, -, *, /
3. Opening and closing brackets - () - are used to impact precedence of operations
4. + and - have equal precedence which is less than * and /. * and / also have equal precedence.
5. In two operators of equal precedence give preference to the one on left.
6. All operands are single digit numbers.
Sample Input
a*(b-c+d)/e
Sample Output
abc-d+*e/
/*a+-bcde

#include <iostream>
#include <string>
#include <stack>
using namespace std;

int precedence(char ch){
    if(ch == '+' || ch == '-'){
        return 1;
    }else if(ch == '*' || ch == '/'){
        return 2;
    }
    return 0;
}

int main() {
    string str;
    getline(cin,str);

    //Algorithm for Infix Coversion:
    //1. Make prefix Operand Stack, postfix Operand Stack and an Operator Stack.
    //2. Rules are same as Infix Evaluations.
    //3. At the end, Operators Stack can be empty. 
    stack<string> prefix;
    stack<string> postfix;
    stack<char> optors;

    for(int i=0;i<str.length();i++){
        char ch = str[i];
        if(ch == '('){
            optors.push(ch);
        }else if((ch >= '0' && ch <= '9') || (ch >= 'a' && ch <= 'z') || (ch >= 'A' && ch <= 'Z')){
            prefix.push(string(1,ch));
            postfix.push(string(1,ch));
        }else if(ch == ')'){
            while(optors.top() != '('){
                char optor = optors.top();
                optors.pop();
                
                string prev2 = prefix.top();
                prefix.pop();
                string prev1 = prefix.top();
                prefix.pop();
                string prev = optor + prev1 + prev2;
                prefix.push(prev);

                string postv2 = postfix.top();
                postfix.pop();
                string postv1 = postfix.top();
                postfix.pop();
                string postv = postv1 + postv2 + optor;
                postfix.push(postv);
            }
            optors.pop();
        }else if(ch == '+' || ch == '-' || ch == '*' || ch == '/'){
            while(!optors.empty() && optors.top() != '(' && precedence(ch) <= precedence(optors.top())){
                char optor = optors.top();
                optors.pop();
                
                string prev2 = prefix.top();
                prefix.pop();
                string prev1 = prefix.top();
                prefix.pop();
                string prev = optor + prev1 + prev2;
                prefix.push(prev);

                string postv2 = postfix.top();
                postfix.pop();
                string postv1 = postfix.top();
                postfix.pop();
                string postv = postv1 + postv2 + optor;
                postfix.push(postv);
            }
            optors.push(ch);
        }
    }
    while(!optors.empty()){
        char optor = optors.top();
        optors.pop();
        
        string prev2 = prefix.top();
        prefix.pop();
        string prev1 = prefix.top();
        prefix.pop();
        string prev = optor + prev1 + prev2;
        prefix.push(prev);

        string postv2 = postfix.top();
        postfix.pop();
        string postv1 = postfix.top();
        postfix.pop();
        string postv = postv1 + postv2 + optor;
        postfix.push(postv);
    }

    cout<<postfix.top()<<endl;
    cout<<prefix.top()<<endl;
    return 0;    
}
