1. You are given an infix expression.
2. You are required to evaluate and print it's value.
Constraints
1. Expression is balanced
2. The only operators used are +, -, *, /
3. Opening and closing brackets - () - are used to impact precedence of operations
4. + and - have equal precedence which is less than * and /. * and / also have equal precedence.
5. In two operators of equal precedence give preference to the one on left.
6. All operands are single digit numbers.
Sample Input
2 + 6 * 4 / 8 - 3
Sample Output
2

#include <iostream>
#include <string>
#include <cctype>
#include <stack>
using namespace std;

int precedence(char optor){
    if(optor == '+' || optor == '-'){
        return 1;
    }else if(optor == '*' || optor == '/'){
        return 2;
    }
    return 0;
}

int operation(int v1,int v2,char optor){
    if(optor == '+'){
        return (v1+v2);
    }else if(optor == '-'){
        return (v1-v2);
    }else if(optor == '*'){
        return (v1*v2);
    }else if(optor == '/'){
        return (v1/v2);
    }
    return 0;
}

int main() {
    string str;
    getline(cin,str);
    //Algorithm for Infix Evaluation :
    //1. Create two stacks for storing operators(+,-,*,/,(,)) and operands(0 to 9 digits) value, Operand Stack & Operator Stack
    stack<int> oprnds;
    stack<char> optors;

    //2. four Rules of the Infix Evaluation Algorithm:
    for(int i=0;i<str.length();i++){
        char ch = str[i];

        //Rule 1 : '(' or opening bracket ata hai toh Operator Stack peh push ho jata hai
        if(ch == '('){ //Operator
            optors.push(ch);

        }else if(isdigit(ch)){//Operand
        //Rule 2 : Operands(digits) ata hai toh Operand Stack peh push ho jata hai 
            oprnds.push(ch - '0');
        
        }else if(ch == ')'){
        //Rule 3 : ')' or closing bracket ata hai toh tab tak pop hota hai jab tak '(' or opening bracket dikh nhi jata 
        // aur ek pop extra hota hai '(' or opening bracket ko nikal ne ke liye.  

            while(optors.top() != '('){
                char optor = optors.top();
                optors.pop();
                int v2 = oprnds.top();
                oprnds.pop();
                int v1 = oprnds.top();
                oprnds.pop(); //Infix conversion, operand stack meh top ke niche wala value 1 mana jayega aur top wala value 2 hoga 
                
                int opv = operation(v1,v2,optor);
                oprnds.push(opv);
            }
            optors.pop();

        }else if(ch == '+' || ch == '-' || ch == '*' || ch == '/'){
        //Rule 4 : Operators(+,-,*,/) ata hai toh khud se bara ya barabar priority wale operators ko pop kar diya jata hai jab tak 
        // use '(' or opening bracket nhi dikh jata ya Operator Stack empty nhi ho jata 
            
            //ch is wanting higher priority operators solve first
            while(!optors.empty() && optors.top() != '(' && precedence(ch) <= precedence(oprnds.top())){
                char optor = optors.top();
                optors.pop();
                int v2 = oprnds.top();
                oprnds.pop();
                int v1 = oprnds.top();
                oprnds.pop(); //In Infix conversion, Operand stack meh top ke niche wala value 1 mana jayega aur top wala value 2 hoga 
                
                int opv = operation(v1,v2,optor);
                oprnds.push(opv);
            }
            //ch is pushing itself now
            optors.push(ch);
        }
    }

    //3. Sometimes, Operator Stack still not empty
    while(!optors.empty()){
        char optor = optors.top();
        optors.pop();
        int v2 = oprnds.top();
        oprnds.pop();
        int v1 = oprnds.top();
        oprnds.pop(); //In Infix conversion, Operand stack meh top ke niche wala value 1 mana jayega aur top wala value 2 hoga 
        
        int opv = operation(v1,v2,optor);
        oprnds.push(opv);
    }

    cout<<oprnds.top();
    return 0;
}
